ğŸ”¥ The Ultimate Array Problem-Solving Question Technique ğŸ”¥
Whenever you see an array problem, ask yourself the following guiding questions. These will lead you directly to the best approach for solving the problem efficiently.

1ï¸âƒ£ How Do You Need to Traverse the Array?
ğŸ”¹ From Start to End?

âœ… Use a single loop if each element is processed in order (e.g., sum, max, min).
âœ… Kadaneâ€™s Algorithm (max subarray sum), prefix sum, or sliding window often follow this pattern.
ğŸ”¹ From Both Ends?

âœ… Use Two-Pointer Technique (e.g., Trapping Rain Water, Two Sum in sorted array).
âœ… Works well when comparing elements from both sides.
ğŸ”¹ From Middle Outward?

âœ… Binary Search problems often require this (e.g., finding peak element).
âœ… Works for palindrome-related problems (expand from the center).
2ï¸âƒ£ Do You Need to Track Min/Max Values While Traversing?
ğŸ”¹ Yes? â†’ Consider:

âœ… Prefix Max / Suffix Max (e.g., Trapping Rain Water).
âœ… Kadaneâ€™s Algorithm (max subarray sum).
âœ… Monotonic Stack (next greater/smaller element problems).
ğŸ”¹ No? â†’ Likely a sorting-based or simple traversal problem.

3ï¸âƒ£ Do You Need to Find a Pair, Triplet, or Subarray?
ğŸ”¹ Pair (Two Elements)?

âœ… Two-Pointer Approach (if sorted).
âœ… HashMap / HashSet (if sum or difference needs to be checked).
ğŸ”¹ Triplet / Quadruplet?

âœ… Sorting + Two-Pointer (e.g., Three Sum).
âœ… HashMap for frequency counting.
ğŸ”¹ Subarray / Substring?

âœ… Sliding Window (if contiguous elements matter).
âœ… Kadaneâ€™s Algorithm (if looking for max sum subarray).
âœ… Prefix Sum (if subarray sums need to be computed efficiently).
4ï¸âƒ£ Do You Need to Modify the Array In-Place?
ğŸ”¹ Yes? â†’

âœ… Two-Pointer (slow/fast approach) for removing elements efficiently.
âœ… In-place swaps (for sorting-based problems).
âœ… Use a single loop if modification can be done inline.
ğŸ”¹ No? â†’

âœ… Can use extra space (HashMap, auxiliary arrays, etc.).
5ï¸âƒ£ Do You Need to Search for an Element Efficiently?
ğŸ”¹ Is the Array Sorted?

âœ… Binary Search (O(log n) search time).
âœ… Two-Pointer (for sum-based problems).
ğŸ”¹ Is the Array Unsorted?

âœ… Use HashSet/HashMap (O(1) lookup for duplicates or existence check).
âœ… Sort first, then use binary search (if needed).
6ï¸âƒ£ Does Order Matter?
ğŸ”¹ Yes?

âœ… Sorting-based approaches work well (merge intervals, triplets).
âœ… Prefix sum helps maintain cumulative order.
ğŸ”¹ No?

âœ… Use HashMap / HashSet (unordered lookups are faster).
âœ… Sorting may not be necessary.
7ï¸âƒ£ Is It a Sum/Count Problem?
ğŸ”¹ Fixed-length sum?

âœ… Prefix sum (precompute).
âœ… Sliding window (for moving subarray sums).
ğŸ”¹ Variable-length sum?

âœ… Sliding window (expanding/shrinking to find min/max sum).
ğŸ”¹ Multiple queries?

âœ… Prefix sum (O(1) query after O(n) preprocessing).
8ï¸âƒ£ Is the Array Mutating Over Time?
ğŸ”¹ Do elements change after queries?

âœ… Use Fenwick Tree / Segment Tree for efficient updates.
ğŸ”¹ Is the array static after initial setup?

âœ… Precompute prefix sums, sorting, etc.
ğŸ“Œ APPLYING THIS TO "TRAPPING RAIN WATER"
Step 1: How Do You Need to Traverse?
âœ… From both ends (left and right) â†’ Two-Pointer Approach

Step 2: Do You Need to Track Min/Max Values?
âœ… Yes, track leftMax & rightMax â†’ Helps determine trapped water.

Step 3: Do You Need to Find a Pair, Triplet, or Subarray?
âŒ No, but we compare neighboring elements to decide how much water can be stored.

Step 4: Do You Need to Modify the Array In-Place?
âŒ No modifications, just calculations.

Step 5: Do You Need to Search for an Element?
âŒ No searching, just traversal.

Final Conclusion: Use the Two-Pointer Approach with leftMax & rightMax to efficiently compute the trapped water in O(n). âœ…

ğŸ”¥ FINAL TAKEAWAY
Whenever you're stuck on an array problem, ask yourself these 8 questions in order. The answers will directly lead you to the right approach every time! ğŸš€
